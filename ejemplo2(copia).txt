import Biblioteca;
prop Usuario(Usuario){libros_prestados:int}
prop Profesor():Usuario //Herencia de proposicion???
prop Becario():Usuario

Accion PrestarLibro(U:Usuario,L:Libro): #Restriccion de tipos

    Condiciones:

        P = Prestamos(U,_); //Variable _ desconocida. Puede ser cualquiera. Se puede dejar vacio?
        Output("Prestamo Usuario %1 con libro %2",P.Usuario,P.Libro);// Deberia mostrar varios prestamos
        //filter P in P.fecha_devolucion < Max(P.fecha_devolucion)//funcion de ejemplo,no es valida
        Count(P) < 3; 
        Not Prestamos(_,L); 
        Not Sancionado(U); // El usuario no debe de estar sancionado

    Consecuencias:

        P2 = Prestamos(U,L); //Aqui se esta añadiendo(u obteniendo si ya estaba) un elemento a Prestamos y guardandolo en una variable(uno solo suponiendo que U,L solo tengan un valor)
        P2.fecha_devolucion = Time.Next(14);//Devuelve un tipo de fecha 14 dias despues del dia actual;

    Excepcion Profesor:
        Condiciones: //Se vuelve a intentar con nuevas condiciones

            Or(
                //Los profesores y Becarios no tienen limite de libros ni pueden estar sancionados
                Profesor(U);
                Becario(U);
            );
            Not Prestamos(_,L);
        Consecuencias: //Opcional.Puede añadir nuevas consecuencias(Pero las anteriores se consevan y se efectuan despues de estas)

Accion DevolverLibro(L:Libro):

    Condiciones:
        P = Prestamos(_,L);
    Consecuencias:        
        Del P;
    Contingencias:// si ademas de las condiciones de la accion se cumple estas condiciones, se ejecuta las consecuencias de la Contingencia
        Condiciones: 
            P.fecha_devolucion > Time.Today();
        Consecuencias:
            S = Sancionado(P.Usuario);
            T = Time.Today - P.fecha_devolucion
            S.tiempo = Time.Next(T);
            Biblioteca.enviarAvisoSancion(P.usuario,S.tiempo);//funcion externa

Regla Sancionar(U):// Otra forma sin tener que usar una Excepcion
    Condiciones:
        Or(
            Not Profesor(U);
            Not Becario(U);
        );
    Consecuencias
        Sancionar(U);


Accion MostrarUsuariosMasPrestamos():// NO SE PUEDE REPRESENTAR
    Condiciones:
        P = Prestamos(_,_)


P.count: todas las proposiciones tienen un atributo count con el numero de elementos que contienen.
P.Usuario: Devolveria un usuario por cada elemento P. Si se quiere estar seguro de que solo hay uno hay que usar count
Primero se comprueba si el atributo P.atributo es un atributo de variable, luego si es de proposicion y finalmente si es un individuo de la proposicion(P.Usuario). Si hay otro punto con atributo, entonces se hace lo mismo pero ignorando los atributos de variables.
Puede ser una funcion en vez de un atributo?

Tipos de objetos: Variables, Conjuntos elementos de proposicion, elemento de proposicion, individuos???

ALL????ANY??? Mejor no, innecesario
Se puede considerar max o min como funciones de variables?

C = P.count// las variables pueden contener conjuntos de proposiciones u otros valores. Clase Variables y luego clases hijas como VariableProposicion o VariableINT

terminarl clear, reset....

prop persistente Prestasmo() ???? para indicar que debe de guardarse en disco duro?

Los usuarios y prestamos se tienen que obtener simulando una base de datos,