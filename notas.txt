-Restriciones de tipos?
-Variables 
    --Nuevo clase Variables
    --Atributos por defecto: count
    --Conjunto de elementos de proposicion
    --Varios tipos variables: Proposicion, int,bool...
-RetornoProposiciones
    --Las proposiciones deben de devolver el conjunto de elementos validos
    --Deben admitir las nuevas variables(conjunto de elementos)
    --Deben admitir _ que indica cualquier individuo.
-AtributosProposiciones
    --Se deben eliminar las categorias

-import 
    --Atributos y funciones?
    --Time y Output importados por defecto

-proposiciones y funciones
    --Deben de admitir atributos del tipo P.fecha_devolucion o con variables X.count()

-Contingencias y Excepciones
-herencia proposicion

-Terminal usuario final

-Persistencia? para el proxicmo sprint

#####MAS NOTAS#####

la asignacion de variables es un tipo de condicion
variable = Proposicion| Variable.atributo | funcion| int | bool

proposicion
los parametros que acepta una proposicion son: Variables(con o sin atributos o funcion), _(o vacio) o datos basicos(string,int,bool). Los tipos como date no se pueden asignar manualmente.
Las Variables solo deben ser aceptadas en la gramatica, el motor debe usar cada posible combinacion de variables de una en una y luego devolver todas las validas dentro de una unica variable



cada accion tiene un diccion de variables algo como 
mi_dicc = {
    "X": "Ada",
    "U": objeto tipo ElementoProposicion,
    "Cuenta": 3,
    "Fecha" : objeto date
}

X.count es una funcion de agregacion que comprueba si el valor es una lista y si es asi devuelve el count. Mejor que todos sean una lista, aunque solo tengan un elemento
Las funciones de agregacion se deben calcular antes de entrar en la condicion, en la regla
Cuando el parser detecte un atributo de variable(que tambien se podria llamar de agregacion) debe marcar la variable con un *, por ejemplo: P.count < 3; en la condicion se añadira  cond.variables.append("*P"). Puede darse el caso de dos variables ["P","*P"], en principio no importaria. Podria ser el caso de buscar todos los prestamos(P) realizados por el usuario con mas prestamos(*P). Se calcularia *P antes de entrar y luego se realizaria el filtrado uno por uno.

las VariableProposicion tienen atributo count(que solo se modifica al crearse en una condicion asignacion?)

Cada condicion debe de tener registradas el nombre de las variables que necesita. Al empezar una condicion se les pasara cada combinacion posible de valores para las variables de una en una. Y devolvera una nueva variable con tantos valores como hayan sido validos. Por ejemplo  P = Prestamos(U,L) y U y L contienen cada uno varios valores, por cada par valido se creara un objeto ElementoProposicion que se añadira a P
Fechas = P.fecha_devolucion > Time.Today() Esto no esta definido(por el momento)
Seria valido
Fechas = P.fecha_devolucion y seria una variable con varias Fechas
P.fecha_devolucion > Time.Today()


filter P in
ALL P in
any  P in
Count P ??? 
La estrategia cuando hay una variable multiple sin agregar es coger solo el primero e ignorar el resto. Lanzar un warning dinamico

NO PUEDE HABER ASIGANCION DE VARIABLES DENTRO DE UNA CONDICIONLOGICA!!!!!




Funciones y agregacion
METODO 1

import System

condiciones:
System.funcion("df",M,3,M2,_) < 3;   // Se tiene que recoger un conjunto no valido para M y M2. Ej M={2,3,4} M2={5,6,7} --> no validos [{M:2,M2:5}, {M:3,M2:6}]
L = algo(C,_);
L.valor2 > 3;
P = System.funcion2(M); //No permitido _ en funciones, solo en predicados
M = System.Count(*P);
System.funcion3(P);
P.valor <= System.Max(L.valor2);
P.algo == M.algo For P//Cual variable se tiene que eliminar del contexto? Una opcion seria expecificarlo con For P cuando exista en una comparacion varias variables

//System es como una variable pero cuando hay () en el atributo, entonces es una funcion. *P indica que se quiere tratar todo los elementos de P de una sola vez(agregacion)
hola(nacho(x,y,f()))